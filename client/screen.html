<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ü•ß Vibe Cod'in Pie</title>
  <!-- Favicon -->
  <link rel="icon" href="/favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&family=Google+Sans+Text:wght@400;500;700&family=Noto+Sans+SC:wght@400;500;700&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,1,0" rel="stylesheet" />
  <!-- CodeMirror 5 -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/codemirror.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/theme/material-darker.min.css" />
  <style>
    /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       Material 3 ‚Äî Dark Theme Design Tokens
       Based on M3 Baseline Dark Scheme
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
    :root {
      --md-sys-color-primary:             #D0BCFF;
      --md-sys-color-on-primary:          #381E72;
      --md-sys-color-primary-container:   #4F378B;
      --md-sys-color-on-primary-container:#EADDFF;
      --md-sys-color-secondary:             #CCC2DC;
      --md-sys-color-on-secondary:          #332D41;
      --md-sys-color-secondary-container:   #4A4458;
      --md-sys-color-on-secondary-container:#E8DEF8;
      --md-sys-color-tertiary:             #EFB8C8;
      --md-sys-color-on-tertiary:          #492532;
      --md-sys-color-tertiary-container:   #633B48;
      --md-sys-color-on-tertiary-container:#FFD8E4;
      --md-sys-color-error:             #F2B8B5;
      --md-sys-color-on-error:          #601410;
      --md-sys-color-error-container:   #8C1D18;
      --md-sys-color-on-error-container:#F9DEDC;
      --md-sys-color-surface:             #141218;
      --md-sys-color-on-surface:          #E6E0E9;
      --md-sys-color-surface-variant:     #49454F;
      --md-sys-color-on-surface-variant:  #CAC4D0;
      --md-sys-color-surface-dim:           #141218;
      --md-sys-color-surface-bright:        #3B383E;
      --md-sys-color-surface-container-lowest: #0F0D13;
      --md-sys-color-surface-container-low:    #1D1B20;
      --md-sys-color-surface-container:        #211F26;
      --md-sys-color-surface-container-high:   #2B2930;
      --md-sys-color-surface-container-highest:#36343B;
      --md-sys-color-outline:         #938F99;
      --md-sys-color-outline-variant: #49454F;
      --md-sys-color-inverse-surface:    #E6E0E9;
      --md-sys-color-inverse-on-surface: #322F35;
      --md-sys-color-inverse-primary:    #6750A4;
      --md-sys-color-shadow:     #000000;
      --md-sys-color-scrim:      #000000;
      --md-sys-state-hover-opacity:   0.08;
      --md-sys-state-focus-opacity:   0.12;
      --md-sys-state-pressed-opacity: 0.12;
      --md-sys-typescale-display-font:   'Google Sans', 'Noto Sans SC', sans-serif;
      --md-sys-typescale-headline-font:  'Google Sans', 'Noto Sans SC', sans-serif;
      --md-sys-typescale-title-font:     'Google Sans Text', 'Noto Sans SC', sans-serif;
      --md-sys-typescale-body-font:      'Google Sans Text', 'Noto Sans SC', sans-serif;
      --md-sys-typescale-label-font:     'Google Sans Text', 'Noto Sans SC', sans-serif;
      --md-sys-shape-corner-none:        0px;
      --md-sys-shape-corner-extra-small: 4px;
      --md-sys-shape-corner-small:       8px;
      --md-sys-shape-corner-medium:      12px;
      --md-sys-shape-corner-large:       16px;
      --md-sys-shape-corner-extra-large: 28px;
      --md-sys-shape-corner-full:        9999px;
      --md-sys-elevation-1: 0 1px 3px 1px rgba(0,0,0,0.15), 0 1px 2px 0 rgba(0,0,0,0.3);
      --md-sys-elevation-2: 0 2px 6px 2px rgba(0,0,0,0.15), 0 1px 2px 0 rgba(0,0,0,0.3);
      --md-sys-elevation-3: 0 4px 8px 3px rgba(0,0,0,0.15), 0 1px 3px 0 rgba(0,0,0,0.3);
    }
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%; overflow: hidden;
      background: var(--md-sys-color-surface);
      color: var(--md-sys-color-on-surface);
      font-family: var(--md-sys-typescale-body-font);
      -webkit-font-smoothing: antialiased;
    }
    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--md-sys-color-outline-variant); border-radius: var(--md-sys-shape-corner-full); }
    .material-symbols-rounded {
      font-family: 'Material Symbols Rounded';
      font-weight: normal; font-style: normal; font-size: 24px;
      line-height: 1; letter-spacing: normal;
      text-transform: none; display: inline-block;
      white-space: nowrap; word-wrap: normal;
      direction: ltr; font-feature-settings: 'liga';
      -webkit-font-smoothing: antialiased;
    }
    #start-overlay {
      position: fixed; inset: 0; z-index: 1000;
      display: flex; flex-direction: column;
      justify-content: center; align-items: center; gap: 24px;
      background: var(--md-sys-color-scrim);
      opacity: 1;
      transition: opacity 0.3s cubic-bezier(0.2, 0, 0, 1);
    }
    #start-overlay.hidden { opacity: 0; pointer-events: none; }
    #start-btn {
      font-family: var(--md-sys-typescale-label-font);
      font-size: 16px; font-weight: 500; letter-spacing: 0.1px;
      padding: 16px 32px; border: none;
      border-radius: var(--md-sys-shape-corner-large);
      background: var(--md-sys-color-primary-container);
      color: var(--md-sys-color-on-primary-container);
      cursor: pointer;
      box-shadow: var(--md-sys-elevation-3);
      transition: background 0.2s, box-shadow 0.2s, transform 0.1s;
      display: flex; align-items: center; gap: 12px;
    }
    #start-btn:hover { filter: brightness(1.08); }
    #start-btn:active { transform: scale(0.97); }
    #start-btn .material-symbols-rounded { font-size: 24px; }
    #start-overlay .subtitle {
      font-family: var(--md-sys-typescale-body-font);
      font-size: 14px; color: var(--md-sys-color-on-surface-variant);
    }
    #app { display: flex; flex-direction: column; width: 100%; height: 100%; }
    #header {
      display: flex; justify-content: space-between; align-items: center;
      padding: 0 16px; height: 64px; min-height: 64px;
      background: var(--md-sys-color-surface);
      z-index: 20; position: relative;
    }
    #title {
      font-family: var(--md-sys-typescale-title-font);
      font-size: 22px; font-weight: 400;
      color: var(--md-sys-color-on-surface);
      display: flex; align-items: center; gap: 8px;
    }
    #title .material-symbols-rounded { font-size: 28px; color: var(--md-sys-color-primary); }
    #controls { display: flex; gap: 8px; align-items: center; }
    .md-tonal-btn {
      font-family: var(--md-sys-typescale-label-font);
      font-size: 14px; font-weight: 500; letter-spacing: 0.1px;
      padding: 0 24px; height: 40px; border: none;
      border-radius: var(--md-sys-shape-corner-full);
      background: var(--md-sys-color-secondary-container);
      color: var(--md-sys-color-on-secondary-container);
      cursor: pointer;
      transition: filter 0.15s, transform 0.1s;
      display: inline-flex; align-items: center; gap: 8px;
    }
    .md-tonal-btn:hover { filter: brightness(1.08); }
    .md-tonal-btn:active { transform: scale(0.97); }
    .md-tonal-btn .material-symbols-rounded { font-size: 18px; }
    .md-tonal-btn.active {
      background: var(--md-sys-color-primary-container);
      color: var(--md-sys-color-on-primary-container);
    }
    .md-outlined-btn {
      font-family: var(--md-sys-typescale-label-font);
      font-size: 14px; font-weight: 500; letter-spacing: 0.1px;
      padding: 0 24px; height: 40px;
      border: 1px solid var(--md-sys-color-outline);
      border-radius: var(--md-sys-shape-corner-full);
      background: transparent;
      color: var(--md-sys-color-on-surface-variant);
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
      display: inline-flex; align-items: center; gap: 8px;
    }
    .md-outlined-btn:hover { background: rgba(202,196,208, var(--md-sys-state-hover-opacity)); }
    .md-outlined-btn:active { transform: scale(0.97); }
    .md-outlined-btn .material-symbols-rounded { font-size: 18px; }
    #status-text {
      font-family: var(--md-sys-typescale-label-font);
      font-size: 12px; font-weight: 500;
      color: var(--md-sys-color-on-surface-variant);
      padding: 0 12px; height: 32px;
      display: inline-flex; align-items: center; gap: 6px;
      border: 1px solid var(--md-sys-color-outline-variant);
      border-radius: var(--md-sys-shape-corner-small);
      background: transparent;
    }
    #main { flex: 1; display: flex; position: relative; overflow: hidden; }
    #code-display {
      flex: 1; position: relative; overflow: hidden;
      display: flex; flex-direction: column;
      margin: 0 12px 0 16px; z-index: 10;
    }
    #code-label {
      padding: 12px 16px;
      font-family: var(--md-sys-typescale-label-font);
      font-size: 12px; font-weight: 500;
      letter-spacing: 0.5px; text-transform: uppercase;
      color: var(--md-sys-color-on-surface-variant);
      background: var(--md-sys-color-surface-container);
      border-radius: var(--md-sys-shape-corner-large) var(--md-sys-shape-corner-large) 0 0;
      display: flex; align-items: center; gap: 8px;
    }
    #code-label .dot {
      width: 8px; height: 8px; border-radius: var(--md-sys-shape-corner-full);
      background: var(--md-sys-color-tertiary);
      animation: pulse-dot 2s ease-in-out infinite;
    }
    #code-label .dot.stopped { background: var(--md-sys-color-outline); animation: none; }
    @keyframes pulse-dot { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
    /* CodeMirror editor container */
    #code-editor-wrap {
      flex: 1; overflow: hidden;
      background: var(--md-sys-color-surface-container-low);
    }
    /* M3 theme overrides for CodeMirror */
    .CodeMirror {
      height: 100% !important;
      background: var(--md-sys-color-surface-container-low) !important;
      font-family: 'JetBrains Mono', monospace !important;
      font-size: 14px !important;
      line-height: 1.7 !important;
      color: var(--md-sys-color-on-surface) !important;
      padding: 8px 0;
    }
    .CodeMirror-gutters {
      background: var(--md-sys-color-surface-container) !important;
      border-right: 1px solid var(--md-sys-color-outline-variant) !important;
    }
    .CodeMirror-linenumber {
      color: var(--md-sys-color-outline) !important;
      font-size: 11px !important;
    }
    .CodeMirror-cursor {
      border-left-color: var(--md-sys-color-primary) !important;
    }
    .CodeMirror-selected {
      background: rgba(208,188,255,0.18) !important;
    }
    .CodeMirror-focused .CodeMirror-selected {
      background: rgba(208,188,255,0.25) !important;
    }
    .CodeMirror-matchingbracket {
      color: var(--md-sys-color-tertiary) !important;
      font-weight: 700;
      text-decoration: underline;
    }
    .CodeMirror-scrollbar-filler,
    .CodeMirror-gutter-filler { background: transparent !important; }
    .cm-s-material-darker .cm-keyword { color: #C792EA !important; }
    .cm-s-material-darker .cm-string { color: #C3E88D !important; }
    .cm-s-material-darker .cm-number { color: #F78C6C !important; }
    .cm-s-material-darker .cm-comment { color: #6A737D !important; }
    .cm-s-material-darker .cm-def { color: #82AAFF !important; }
    .cm-s-material-darker .cm-property { color: var(--md-sys-color-primary) !important; }
    .cm-s-material-darker .cm-operator { color: #89DDFF !important; }
    .cm-s-material-darker .cm-variable { color: var(--md-sys-color-on-surface) !important; }
    .cm-s-material-darker .cm-variable-2 { color: #EEFFFF !important; }
    .cm-s-material-darker .cm-atom { color: #F78C6C !important; }
    /* Editor action bar */
    #editor-actions {
      display: flex; align-items: center; gap: 8px;
      padding: 6px 12px;
      background: var(--md-sys-color-surface-container);
      border-top: 1px solid var(--md-sys-color-outline-variant);
    }
    .md-text-btn {
      font-family: var(--md-sys-typescale-label-font);
      font-size: 12px; font-weight: 500; letter-spacing: 0.1px;
      padding: 0 12px; height: 32px; border: none;
      border-radius: var(--md-sys-shape-corner-full);
      background: transparent;
      color: var(--md-sys-color-primary);
      cursor: pointer;
      transition: background 0.15s;
      display: inline-flex; align-items: center; gap: 6px;
    }
    .md-text-btn:hover { background: rgba(208,188,255, var(--md-sys-state-hover-opacity)); }
    .md-text-btn .material-symbols-rounded { font-size: 16px; }
    #editor-hint {
      font-family: var(--md-sys-typescale-label-font);
      font-size: 11px; color: var(--md-sys-color-outline);
      margin-left: auto;
    }
    #test-canvas { z-index: 1 !important; opacity: 0.6 !important; }
    #scope-canvas {
      width: 100%; height: 56px; min-height: 56px;
      background: var(--md-sys-color-surface-container-lowest);
      border-radius: 0 0 var(--md-sys-shape-corner-large) var(--md-sys-shape-corner-large);
    }
    /* ‚îÄ‚îÄ Inline Visualization Widgets (CM5 line widgets) ‚îÄ‚îÄ */
    .cm-inline-widget {
      padding: 4px 0 4px 30px;
      background: transparent;
      overflow: hidden;
      position: relative;
    }
    .cm-inline-widget canvas {
      display: block;
      width: calc(100% - 8px);
      border-radius: var(--md-sys-shape-corner-small);
      background: rgba(15, 13, 19, 0.55);
      border: 1px solid var(--md-sys-color-outline-variant);
    }
    .cm-inline-widget .widget-label {
      position: absolute;
      top: 6px; right: 14px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 9px; font-weight: 500;
      color: var(--md-sys-color-outline);
      pointer-events: none;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* ‚îÄ‚îÄ Interactive Sliders ‚îÄ‚îÄ */
    #slider-container {
      display: none; flex-direction: column; gap: 8px;
      padding: 12px;
      background: var(--md-sys-color-surface-container-low);
      border-top: 1px solid var(--md-sys-color-outline-variant);
      max-height: 200px; overflow-y: auto;
    }
    .slider-row {
      display: flex; align-items: center; gap: 12px;
    }
    .slider-label {
      font-family: 'JetBrains Mono', monospace; font-size: 11px;
      min-width: 100px; color: var(--md-sys-color-on-surface-variant);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .slider-input {
      flex: 1; accent-color: var(--md-sys-color-primary); height: 4px;
      -webkit-appearance: none; appearance: none;
      background: var(--md-sys-color-outline-variant);
      border-radius: var(--md-sys-shape-corner-full);
      outline: none;
    }
    .slider-input::-webkit-slider-thumb {
      -webkit-appearance: none; width: 12px; height: 12px;
      background: var(--md-sys-color-primary); border-radius: 50%;
      cursor: pointer; transition: transform 0.1s;
    }
    .slider-input::-webkit-slider-thumb:hover { transform: scale(1.2); }
    .slider-value {
      font-family: 'JetBrains Mono', monospace; font-size: 11px;
      min-width: 45px; text-align: right; color: var(--md-sys-color-primary);
    }

    #sidebar {
      width: 180px; padding: 12px;
      display: flex; flex-direction: column;
      align-items: center; gap: 12px;
      background: var(--md-sys-color-surface);
      z-index: 20; position: relative; margin-right: 16px;
    }
    #qr-container {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      background: var(--md-sys-color-surface-container-high);
      border-radius: var(--md-sys-shape-corner-medium);
      padding: 12px; text-align: center;
    }
    #qr-container img { border-radius: var(--md-sys-shape-corner-small); }
    #qr-label {
      margin-top: 8px;
      font-family: var(--md-sys-typescale-label-font);
      font-size: 12px; font-weight: 500;
      color: var(--md-sys-color-primary);
    }
    #pattern-list {
      width: 100%; display: flex; flex-direction: column; gap: 2px;
      overflow-y: auto; flex: 1;
    }
    .pattern-btn {
      font-family: var(--md-sys-typescale-label-font);
      font-size: 12px; font-weight: 500;
      padding: 0 16px; height: 40px;
      border-radius: var(--md-sys-shape-corner-full);
      cursor: pointer; border: none;
      background: transparent;
      color: var(--md-sys-color-on-surface-variant);
      text-align: left; transition: background 0.15s;
      display: flex; align-items: center; gap: 8px;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .pattern-btn:hover { background: rgba(202,196,208, var(--md-sys-state-hover-opacity)); }
    .pattern-btn.active {
      background: var(--md-sys-color-secondary-container);
      color: var(--md-sys-color-on-secondary-container);
      font-weight: 700;
    }
    #ticker {
      padding: 0 24px;
      background: var(--md-sys-color-surface-container);
      overflow: hidden; white-space: nowrap;
      z-index: 20; position: relative;
      height: 48px; min-height: 48px;
      display: flex; align-items: center;
      box-shadow: 0 -1px 0 0 var(--md-sys-color-surface-container-highest);
    }
    #ticker-inner { display: inline-flex; gap: 24px; animation: ticker-scroll 30s linear infinite; }
    .ticker-item {
      font-family: var(--md-sys-typescale-label-font);
      font-size: 12px; font-weight: 500;
      color: var(--md-sys-color-on-surface-variant);
      padding: 0 12px; height: 32px;
      display: inline-flex; align-items: center;
      background: var(--md-sys-color-surface-container-high);
      border-radius: var(--md-sys-shape-corner-small);
      flex-shrink: 0;
    }
    @keyframes ticker-scroll { 0% { transform: translateX(80vw); } 100% { transform: translateX(-100%); } }
    .notification {
      position: fixed; bottom: 72px; left: 50%;
      transform: translateX(-50%) translateY(16px);
      background: var(--md-sys-color-inverse-surface);
      color: var(--md-sys-color-inverse-on-surface);
      padding: 0 16px; height: 48px;
      display: flex; align-items: center;
      border-radius: var(--md-sys-shape-corner-extra-small);
      font-family: var(--md-sys-typescale-body-font);
      font-size: 14px; font-weight: 400;
      box-shadow: var(--md-sys-elevation-3);
      opacity: 0;
      transition: opacity 0.2s cubic-bezier(0.2,0,0,1), transform 0.2s cubic-bezier(0.2,0,0,1);
      z-index: 100; pointer-events: none;
    }
    .notification.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    .spinner {
      display: inline-block; width: 16px; height: 16px;
      border: 2.5px solid transparent;
      border-top-color: var(--md-sys-color-primary);
      border-radius: var(--md-sys-shape-corner-full);
      animation: spin 0.8s linear infinite; vertical-align: middle;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .md-divider { width: 100%; height: 1px; background: var(--md-sys-color-outline-variant); }

/* ‚îÄ‚îÄ Viewer Mode Styles ‚îÄ‚îÄ */
    body.mode-viewer #editor-actions,
    body.mode-viewer #btn-play,
    body.mode-viewer #btn-stop,
    body.mode-viewer #sidebar,
    body.mode-viewer .CodeMirror-cursors {
      display: none !important;
    }
    body.mode-viewer #start-btn {
      display: flex !important;
    }
    body.mode-viewer #title::after {
      content: " (ËßÇ‰ºóÊ®°Âºè)";
      font-size: 0.8em;
      opacity: 0.7;
    }
  </style>
</head>
<body>
  <div id="start-overlay">
    <button id="start-btn">
      <span class="material-symbols-rounded">play_circle</span>
      ÁÇπÂáªÂºÄÂßã
    </button>
    <span class="subtitle">Vibe Cod'in Pie ‚Äî GeekPie Pi Day 2026</span>
  </div>

  <div id="app" style="display:none;">
    <div id="header">
      <div id="title">
        <span class="material-symbols-rounded">music_note</span>
        Vibe Cod'in Pie
      </div>
      <div id="controls">
        <button id="btn-play" class="md-tonal-btn">
          <span class="material-symbols-rounded">play_arrow</span>
          Êí≠Êîæ
        </button>
        <button id="btn-stop" class="md-outlined-btn">
          <span class="material-symbols-rounded">stop</span>
          ÂÅúÊ≠¢
        </button>
        <span id="status-text">ÂàùÂßãÂåñ‰∏≠‚Ä¶</span>
      </div>
    </div>
    <div class="md-divider"></div>
    <div id="main">
      <div id="code-display">
        <div id="code-label">
          <span class="dot stopped" id="play-dot"></span>
          <span id="code-label-text">ÂΩìÂâç‰ª£Á†Å</span>
        </div>
        <div id="code-editor-wrap"></div>
        <div id="editor-actions">
          <button id="btn-run" class="md-text-btn">
            <span class="material-symbols-rounded">play_circle</span>
            ËøêË°å‰ª£Á†Å
          </button>
          <button id="btn-reset" class="md-text-btn">
            <span class="material-symbols-rounded">restart_alt</span>
            ÈáçÁΩÆ
          </button>
          <span id="editor-hint">Ctrl+Enter ËøêË°å</span>
        </div>
        <div id="slider-container"></div>
        <canvas id="scope-canvas"></canvas>
      </div>
      <div id="sidebar">
        <div id="qr-container">
          <img id="qr-img" src="" alt="QR" width="120" height="120" style="display:none;" />
          <div id="qr-label">Êâ´Á†ÅÂèÇ‰∏é</div>
        </div>
        <div class="md-divider"></div>
        <div id="pattern-list"></div>
      </div>
    </div>
    <div id="ticker">
      <div id="ticker-inner">
        <span class="ticker-item">ü•ß Ê¨¢ËøéÊù•Âà∞ Vibe Cod'in Pie!</span>
        <span class="ticker-item">üì± Êâ´Âè≥‰∏äËßí‰∫åÁª¥Á†ÅÊèê‰∫§‰Ω†ÁöÑÈü≥‰πêÊÉ≥Ê≥ï</span>
        <span class="ticker-item">ü§ñ AI ‰ºöÂ∞Ü‰Ω†ÁöÑÊèèËø∞ÂèòÊàêÈü≥‰πê‰ª£Á†Å</span>
      </div>
    </div>
  </div>

  <!-- CodeMirror 5 JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/mode/javascript/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/addon/edit/matchbrackets.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/addon/edit/closebrackets.min.js"></script>
  <script src="https://unpkg.com/@strudel/web@1.3.0"></script>
  <script>
    (function() {
      // üõ†Ô∏è Polyfill for Strudel Reactivity
      // Fixes issue where strudel.ref is missing in some bundles, causing sliders to be non-reactive
      function polyfillStrudel(s) {
        if (!s) return;
        
        console.log('[Polyfill] Checking Strudel capabilities...');
        const hasRef = typeof s.ref === 'function';
        const hasPure = typeof s.pure === 'function';
        const hasReify = typeof s.reify === 'function';
        const hasPattern = typeof s.Pattern === 'function';
        const hasHap = typeof s.Hap === 'function';

        console.log(`[Polyfill] ref:${hasRef} pure:${hasPure} reify:${hasReify} Pattern:${hasPattern} Hap:${hasHap}`);

        // 0. Ensure pure/reify exist if Pattern/Hap are available
        if (!s.pure && s.Pattern && s.Hap) {
             console.log('[Polyfill] Polyfilling pure');
             s.pure = (x) => new s.Pattern((state) => [new s.Hap(state.timespan, x)]);
        }

        if (!s.reify && s.pure) {
             console.log('[Polyfill] Polyfilling reify (simple)');
             s.reify = (x) => (x instanceof s.Pattern ? x : s.pure(x));
        }

        // 1. Polyfill ref if missing
        if (!s.ref) {
           if (s.pure && s.reify) {
              console.log('[Polyfill] Adding strudel.ref support using pure/reify');
              s.ref = (accessor) => s.pure(1).withValue(() => s.reify(accessor())).innerJoin();
           } else {
              console.warn('[Polyfill] Failed to polyfill ref: missing pure/reify');
           }
        }
        
        // 2. Ensure registerWidgetType is accessible
        if (!s.registerWidgetType && s.transpiler && s.transpiler.registerWidgetType) {
           console.log('[Polyfill] Exposing registerWidgetType');
           s.registerWidgetType = s.transpiler.registerWidgetType;
        }
      }

      // Check immediately
      if (typeof strudel !== 'undefined') {
        polyfillStrudel(strudel);
      } else {
        // Capture when it loads
        console.warn('[Polyfill] strudel global not found yet, setting up capture...');
        Object.defineProperty(window, 'strudel', {
          configurable: true,
          enumerable: true,
          get: function() { return this._strudel; },
          set: function(v) {
            this._strudel = v;
            polyfillStrudel(v);
          }
        });
      }
    })();
  </script>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       Strudel Inline Visualization Widgets
       @strudel/web UMD does NOT include @strudel/codemirror, so the
       widget methods (._scope, ._pianoroll, ._punchcard ‚Ä¶) are missing.
       We implement them here: each method creates an inline <canvas>,
       wires up the actual drawing function from @strudel/draw or
       @strudel/webaudio, and queues the canvas for insertion into the
       CodeMirror 5 editor via addLineWidget().
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <script>
  (function() {
    if (typeof strudel === 'undefined' || !strudel.Pattern) {
      console.error('[widget] strudel.Pattern not found ‚Äì UMD failed to load?');
      return;
    }
    var P = strudel.Pattern.prototype;

    // ‚îÄ‚îÄ Register widget types with the transpiler ‚îÄ‚îÄ
    // This makes the transpiler inject unique IDs as the first argument
    // to ._scope(), ._pianoroll() etc. calls during evaluate().
    // NOTE: We do NOT register 'slider' here because the transpiler has
    // native handling for slider(...) calls that generates stable range-based IDs.
    // Registering it here would override that with generic widget handling
    // that fails to generate IDs (causing sliders to disappear or reset).
    window.ensureWidgetsRegistered = function() {
      if (window._widgetsRegistered) return;
      
      var registerWidgetType = strudel.registerWidgetType || (strudel.transpiler && strudel.transpiler.registerWidgetType) || window.registerWidgetType;
      
      if (typeof registerWidgetType === 'function') {
        ['_scope','_pianoroll','_punchcard','_spiral','_pitchwheel','_spectrum','_wordfall'].forEach(function(t) {
          registerWidgetType(t);
        });
        console.log('[widget] Registered widget types with transpiler');
        window._widgetsRegistered = true;
      } else {
        console.warn('[widget] registerWidgetType not found on strudel object yet');
      }
    };

    // Try to register immediately if possible
    if (typeof strudel !== 'undefined') {
       window.ensureWidgetsRegistered();
    }

    // ‚îÄ‚îÄ Inline Widget Canvas System ‚îÄ‚îÄ
    var _inlineWidgets = [];   // CM5 LineWidget handles
    var _pendingWidgets = [];  // {canvas, wrapper, type, id} queue
    var _widgetIdCounter = 0;

    window._clearInlineWidgets = function() {
      _inlineWidgets.forEach(function(w) { try { w.clear(); } catch(e) {} });
      _inlineWidgets = [];
      _pendingWidgets = [];
      _widgetIdCounter = 0;
    };

    window._insertInlineWidgets = function(cmEditor) {
      if (!cmEditor || _pendingWidgets.length === 0) return;
      var code = cmEditor.getValue();
      var lines = code.split('\n');
      // Find lines containing widget method calls
      var widgetRe = /\._(scope|pianoroll|punchcard|spiral|pitchwheel|spectrum|wordfall)\s*\(/;
      var widgetLines = [];
      lines.forEach(function(line, i) {
        var m = line.match(widgetRe);
        if (m) widgetLines.push({ line: i, type: '_' + m[1] });
      });
      // Match pending canvases to editor lines by type order
      var counters = {};
      widgetLines.forEach(function(info) {
        if (!counters[info.type]) counters[info.type] = 0;
        var idx = counters[info.type]++;
        var matching = _pendingWidgets.filter(function(w) { return w.type === info.type; });
        if (matching[idx]) {
          var lw = cmEditor.addLineWidget(info.line, matching[idx].wrapper, {
            coverGutter: false,
            noHScroll: true,
            above: false,
          });
          _inlineWidgets.push(lw);
        }
      });
    };

    function createWidgetCanvas(type, opts) {
      opts = opts || {};
      var id = '_w_' + type + '_' + (_widgetIdCounter++);
      var width = opts.width || 500;
      var height = opts.height || 60;
      var dpr = window.devicePixelRatio || 1;

      var canvas = document.createElement('canvas');
      canvas.id = id;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.height = height + 'px';

      var label = document.createElement('span');
      label.className = 'widget-label';
      label.textContent = type.replace('_', '');

      var wrapper = document.createElement('div');
      wrapper.className = 'cm-inline-widget';
      wrapper.appendChild(canvas);
      wrapper.appendChild(label);

      _pendingWidgets.push({ canvas: canvas, wrapper: wrapper, type: type, id: id });
      return { canvas: canvas, id: id, ctx: canvas.getContext('2d', { willReadFrequently: true }) };
    }

    function parseArgs(args) {
      // The transpiler may inject a string ID as first arg
      if (typeof args[0] === 'string') return args[1] || {};
      return args[0] || {};
    }

    // ‚îÄ‚îÄ _pianoroll: scrolling note visualization ‚îÄ‚îÄ
    P._pianoroll = function() {
      var options = parseArgs(arguments);
      var w = createWidgetCanvas('_pianoroll', options);
      return this.tag(w.id).pianoroll(Object.assign({ fold: 1 }, options, { ctx: w.ctx, id: w.id }));
    };

    // ‚îÄ‚îÄ _punchcard: folded pianoroll ‚îÄ‚îÄ
    P._punchcard = function() {
      var options = parseArgs(arguments);
      var w = createWidgetCanvas('_punchcard', options);
      return this.tag(w.id).pianoroll(Object.assign({ fold: 1 }, options, { ctx: w.ctx, id: w.id }));
    };

    // ‚îÄ‚îÄ _scope: oscilloscope (time-domain waveform) ‚îÄ‚îÄ
    P._scope = function() {
      var options = parseArgs(arguments);
      var w = createWidgetCanvas('_scope', { width: 500, height: 60 });
      return this.scope(Object.assign({ pos: 0.5, scale: 1 }, options, { ctx: w.ctx, id: w.id }));
    };

    // ‚îÄ‚îÄ _spectrum: frequency spectrum ‚îÄ‚îÄ
    P._spectrum = function() {
      var options = parseArgs(arguments);
      var w = createWidgetCanvas('_spectrum', { width: 500, height: 60 });
      if (typeof this.spectrum === 'function') {
        return this.spectrum(Object.assign({}, options, { ctx: w.ctx, id: w.id }));
      }
      return this; // fallback no-op
    };

    // ‚îÄ‚îÄ _spiral: uses pianoroll as fallback (spiral needs onPaint) ‚îÄ‚îÄ
    P._spiral = function() {
      var options = parseArgs(arguments);
      var sz = options.size || 200;
      var w = createWidgetCanvas('_spiral', { width: sz, height: sz });
      return this.tag(w.id).pianoroll(Object.assign({ fold: 1 }, options, { ctx: w.ctx, id: w.id }));
    };

    // ‚îÄ‚îÄ _pitchwheel: uses pianoroll as fallback ‚îÄ‚îÄ
    P._pitchwheel = function() {
      var options = parseArgs(arguments);
      var w = createWidgetCanvas('_pitchwheel', { width: 500, height: 60 });
      return this.tag(w.id).pianoroll(Object.assign({ fold: 1 }, options, { ctx: w.ctx, id: w.id }));
    };

    // ‚îÄ‚îÄ _wordfall: vertical pianoroll with labels ‚îÄ‚îÄ
    P._wordfall = function() {
      var options = parseArgs(arguments);
      var w = createWidgetCanvas('_wordfall', options);
      return this.tag(w.id).pianoroll(Object.assign(
        { vertical: 1, labels: 1, fold: 1, fill: 1 }, options, { ctx: w.ctx, id: w.id }
      ));
    };

    // ‚îÄ‚îÄ slider / sliderWithID integration ‚îÄ‚îÄ
    window._sliderValues = {}; 
    window._sliderMarkers = {}; // Store CM5 TextMarkers
    window._currentSliders = [];

    window.sliderWithID = function(id, value, min, max, step) {
      var fallback = parseFloat(value);
      if (isNaN(fallback)) fallback = 0.5;
      
      // Initialize if not present, OR if code value differs from stored (Code is source of truth)
      if (window._sliderValues[id] === undefined || Math.abs(window._sliderValues[id] - fallback) > 1e-9) {
        window._sliderValues[id] = fallback;
      }
      
      // Reactive Return for Strudel Pattern (Critical for live updates)
      if (typeof strudel !== 'undefined') {
          // Debug available Strudel keys to find ref
          if (!window._strudelDebugLogged) {
              console.log('[Sliders] Strudel keys:', Object.keys(strudel));
              window._strudelDebugLogged = true;
          }

          if (typeof strudel.ref === 'function') {
              // console.log('[Sliders] Using strudel.ref for', id);
              return strudel.ref(() => window._sliderValues[id]);
          }
          // Fallback manual ref implementation: pure(1).withValue(() => reify(val)).innerJoin()
          if (typeof strudel.pure === 'function' && typeof strudel.reify === 'function') {
               console.log('[Sliders] Using manual ref implementation for', id);
               return strudel.pure(1).withValue(() => strudel.reify(window._sliderValues[id])).innerJoin();
          }
          console.warn('[Sliders] strudel.ref/pure not found, returning static value. Keys:', Object.keys(strudel));
      } else {
          console.warn('[Sliders] strudel global not found, returning static value');
      }
      
      return window._sliderValues[id];
    };
    
    // Passthrough for untranspiled slider calls
    window.slider = function(v, min, max, step) {
      var val = parseFloat(v);
      if (isNaN(val)) val = 0.5;
      
      // If used without ID (untranspiled), we can't sync properly, 
      // but we should still try to return a reactive value if possible, 
      // though we don't have a stable ID to track it.
      // Ideally, code should be transpiled.
      return val;
    };

    window._renderSliders = function(widgets) {
      var container = document.getElementById('slider-container');
      if (!container) return;
      
      var sliders = (widgets || [])
        .filter(function(w) { return w && w.type === 'slider'; })
        .map(function(s, idx) {
          // Fix for Strudel v1.3.0+: Transpiler emits widgets with 'from'/'to' but missing 'id'.
          // We reconstruct the stable range-based ID here to ensure state persistence.
          // IMPORTANT: We use ONLY 'from' as ID because 'to' changes when the value length changes (e.g. 5.5 -> 5.67).
          // Using 'from:to' would cause the ID to change during drag, breaking state and markers.
          if (!s.id && typeof s.from === 'number') {
            s.id = 'loc_' + s.from;
          }
          
          // Fallback for widgets without location (should not happen for valid sliders)
          if (!s.id) {
            console.warn('[Sliders] Widget missing ID and location, using unstable index fallback:', s);
            s.id = 'slider_' + idx;
          }
          return s;
        });
      
      window._currentSliders = sliders;
      // console.log('[Sliders] Rendering ' + sliders.length + ' sliders');
      
      if (sliders.length > 0) {
        container.style.display = 'flex';
      } else {
        container.style.display = 'none';
        container.innerHTML = '';
        return;
      }

      // Diffing strategy to preserve focus
      var existingRows = Array.from(container.children);
      var newIds = new Set(sliders.map(function(s) { return s.id; }));
      
      // Remove stale
      existingRows.forEach(function(row) {
        var input = row.querySelector('.slider-input');
        if (input && !newIds.has(input.dataset.id)) {
          row.remove();
        }
      });
      
      // Clear markers map for rebuild? No, keep valid ones.
      // window._sliderMarkers = {}; // Don't clear all, just stale.
      
      // Sync slider definitions to server (for mobile control)
      if (_isMaster && typeof syncSliderDefinitions === 'function') {
        syncSliderDefinitions(sliders.map(function(s) {
          return {
            id: s.id,
            name: s.name || 'Slider ' + (s.id && s.id.indexOf(':') > -1 ? s.id.split(':').pop() : ''),
            min: s.min !== undefined ? parseFloat(s.min) : 0,
            max: s.max !== undefined ? parseFloat(s.max) : 1,
            step: s.step !== undefined ? parseFloat(s.step) : 0.01,
            value: window._sliderValues[s.id]
          };
        }));
      }

      sliders.forEach(function(s, idx) {
        // Fallback: parse from/to from ID
        if ((typeof s.from !== 'number' || typeof s.to !== 'number') && s.id && s.id.indexOf(':') > -1) {
             var parts = s.id.split(':');
             s.from = parseInt(parts[0]);
             s.to = parseInt(parts[1]);
        }

        // Check if exists
        var existingInput = container.querySelector('.slider-input[data-id="' + s.id + '"]');
        
        var min = s.min !== undefined ? parseFloat(s.min) : 0;
        var max = s.max !== undefined ? parseFloat(s.max) : 1;
        var step = s.step !== undefined ? parseFloat(s.step) : 0.01;
        var def = s.value !== undefined ? parseFloat(s.value) : (min + max) / 2;
        
        // Update global value store
        // If code has explicit value, force sync (Code is source of truth during edits)
        if (s.value !== undefined) {
             window._sliderValues[s.id] = parseFloat(s.value);
        } else if (window._sliderValues[s.id] === undefined) {
             // If code has no value (e.g. dynamic) and we have no state, use default
             window._sliderValues[s.id] = def;
        }

        if (existingInput) {
            // Update attributes if changed
            if (existingInput.min != min) existingInput.min = min;
            if (existingInput.max != max) existingInput.max = max;
            if (existingInput.step != step) existingInput.step = step;
            
            // Don't update value if user is interacting?
            // If the value comes from code update (not user drag), we should update.
            // But we can't easily distinguish here.
            // For now, assume code is source of truth, BUT if we are dragging, we don't want jank.
            // window._sliderValues is the single source of truth.
            if (Math.abs(parseFloat(existingInput.value) - window._sliderValues[s.id]) > 1e-9) {
                 existingInput.value = window._sliderValues[s.id];
                 if (existingInput.nextElementSibling) {
                     existingInput.nextElementSibling.textContent = formatValue(parseFloat(existingInput.value), step);
                 }
            }
            
            // Re-bind marker if needed (position check?)
            // We assume marker logic is handled elsewhere or stable enough
            
            return; // Skip creation
        }

        // Create New Row
        var row = document.createElement('div');
        row.className = 'slider-row';
        
        var label = document.createElement('div');
        label.className = 'slider-label';
        label.textContent = s.name || 'Slider ' + (idx + 1);
        
        var input = document.createElement('input');
        input.type = 'range';
        input.className = 'slider-input';
        input.dataset.id = s.id; 
        
        input.min = min;
        input.max = max;
        input.step = step;
        input.value = window._sliderValues[s.id];
        
        // Viewer: Disable interaction
        if (!_isMaster) {
            input.disabled = true;
            input.style.cursor = 'not-allowed';
            input.style.opacity = '0.7';
        }
        
        var valDisplay = document.createElement('div');
        valDisplay.className = 'slider-value';
        valDisplay.textContent = formatValue(parseFloat(input.value), step);
        
        // Create Marker
        if (editor && typeof s.from === 'number' && typeof s.to === 'number') {
             var startPos = editor.posFromIndex(s.from);
             var endPos = editor.posFromIndex(s.to);
             
             var marker = editor.markText(startPos, endPos, { 
                className: 'cm-slider-value-marker',
                atomic: false, 
                clearOnEnter: false,
                title: 'Slider Value'
             });
             window._sliderMarkers[s.id] = marker;
        }

        input.oninput = function() {
          var val = parseFloat(this.value);
          window._sliderValues[s.id] = val;
          valDisplay.textContent = formatValue(val, step);
          
          if (editor && window._sliderMarkers[s.id]) {
            updateSliderCode(s.id, val);
          }
          
          // Notify Strudel (and self) of the change
          // This supports Strudel's internal sliderWithID which listens for 'cm-slider'
          window.postMessage({ type: 'cm-slider', id: s.id, value: val }, '*');
          
          // Sync to server if Master (Real-time)
          if (typeof syncSliderToServer === 'function') {
              syncSliderToServer(s.id, val);
          }
        };

        // Sync full code on release to ensure persistence
        input.onchange = function() {
             if (typeof syncCodeToServer === 'function' && editor) {
                 syncCodeToServer(editor.getValue());
             }
        };

        row.appendChild(label);
        row.appendChild(input);
        row.appendChild(valDisplay);
        container.appendChild(row);
      });
    };

    // Helper to determine decimal places from step
    function getDecimalPlaces(step) {
      if (!step) return 2;
      var str = step.toString();
      if (str.indexOf('.') > -1) {
        return str.split('.')[1].length;
      }
      return 0;
    }

    // Helper to format value based on step precision
    function formatValue(val, step) {
      var decimals = getDecimalPlaces(step);
      // parseFloat handles stripping trailing zeros if they are not significant for the number itself,
      // but toFixed ensures we don't get floating point artifacts like 5.300000001
      return parseFloat(val.toFixed(decimals));
    }

    function updateSliderCode(id, newVal) {
      var marker = window._sliderMarkers[id];
      if (!marker) return;
      
      var pos = marker.find();
      if (!pos) return;
      
      // Get step from the input element to determine formatting
      var input = document.querySelector('.slider-input[data-id="' + id + '"]');
      var step = input ? parseFloat(input.step) : 0.01;
      
      var formattedVal = formatValue(newVal, step);
      var valStr = formattedVal.toString();
      
      // Prevent infinite loop by checking current content
      var currentContent = editor.getRange(pos.from, pos.to);
      if (currentContent === valStr) return;
      
      // Replace
      editor.replaceRange(valStr, pos.from, pos.to, 'slider');
      
      // Re-mark the new range
      var startIndex = editor.indexFromPos(pos.from);
      var newEndIndex = startIndex + valStr.length;
      var newEndPos = editor.posFromIndex(newEndIndex);
      
      var newMarker = editor.markText(pos.from, newEndPos, {
        className: 'cm-slider-value-marker',
        atomic: false,
        clearOnEnter: false
      });
      window._sliderMarkers[id] = newMarker;
    }

    // ‚îÄ‚îÄ Window Message Listener for Slider Sync (Official Strudel Parity) ‚îÄ‚îÄ
    window.addEventListener('message', function(e) {
      if (e.data && e.data.type === 'cm-slider') {
        var id = e.data.id;
        var val = e.data.value;
        if (id && val !== undefined) {
          // Update internal state
          window._sliderValues[id] = parseFloat(val);
          
          // Update UI Slider if exists
          var input = document.querySelector('.slider-input[data-id="' + id + '"]');
          if (input) {
            input.value = val;
            if (input.nextElementSibling) {
              input.nextElementSibling.textContent = parseFloat(val).toFixed(2);
            }
          }
          
          // Update Code
          if (editor && window._sliderMarkers[id]) {
             updateSliderCode(id, parseFloat(val));
          }
        }
      }
    });

    // ‚îÄ‚îÄ Secure Context Check ‚îÄ‚îÄ
    if (!window.isSecureContext && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
      setTimeout(function() {
        showNotification('‚ö†Ô∏è Ê£ÄÊµãÂà∞Èùû HTTPS ÁéØÂ¢ÉÔºöAudioWorklet ÂèØËÉΩÊó†Ê≥ïÂä†ËΩΩ„ÄÇËØ∑‰ΩøÁî® HTTPS ËÆøÈóÆ„ÄÇ');
      }, 2000);
    }

    console.log('[widget] Strudel inline visualization widgets registered ‚úì');
  })();
  </script>

  <script>
    let PATTERNS = [];
    let currentPatternIndex = 0;
    let isPlaying = false;
    let strudelReady = false;
    let _hush = null;
    let _evaluate = null;

    async function fetchState() {
      try {
        const res = await fetch('/api/state');
        const data = await res.json();
        PATTERNS = data.patterns || [];
        updatePatternList();
        if (PATTERNS.length > 0 && editor && editor.getValue().includes('Ê≠£Âú®Âä†ËΩΩ')) {
          showCode(PATTERNS[0].code);
        }
      } catch (e) {
        console.error('Failed to fetch state:', e);
      }
    }

    function updatePatternList() {
      const patternList = document.getElementById('pattern-list');
      if (!patternList) return;
      patternList.innerHTML = '';
      PATTERNS.forEach((p, i) => {
        const btn = document.createElement('button');
        btn.className = 'pattern-btn' + (i === currentPatternIndex ? ' active' : '');
        btn.textContent = p.name;
        btn.title = p.description || '';
        btn.addEventListener('click', () => switchPattern(i));
        patternList.appendChild(btn);
      });
    }

    function setupScopeCanvas() {
      const canvas = document.getElementById('scope-canvas');
      if (!canvas) return;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = canvas.clientWidth * dpr;
      canvas.height = canvas.clientHeight * dpr;
      window.__scopeCtx = canvas.getContext('2d', { willReadFrequently: true });
    }
    setupScopeCanvas();
    window.addEventListener('resize', () => setupScopeCanvas());

    // ‚îÄ‚îÄ Fetch Initial State ‚îÄ‚îÄ
    fetchState();

    // Helper: Debounce function
    function debounce(func, wait) {
      let timeout;
      return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    }

    function getTranspiler() {
      if (typeof strudel !== 'undefined') {
        return strudel.transpiler || strudel.transpile || window.transpiler || window.transpile;
      }
      return window.transpiler || window.transpile;
    }

    // New: Only update sliders from code without running audio
    window.updateSlidersFromCode = function(code) {
      const transpileFn = getTranspiler();
      if (typeof transpileFn === 'function') {
        try {
          if (typeof window.ensureWidgetsRegistered === 'function') {
            window.ensureWidgetsRegistered();
          }
          // Use emitWidgets: true to get sliders
          const result = transpileFn(code, { emitWidgets: true });
          
          if (result.widgets && result.widgets.length > 0) {
              // console.log('[Sliders] Transpiled widgets:', result.widgets.length);
          }
          
          if (typeof window._renderSliders === 'function') {
            window._renderSliders(result.widgets || result.sliders || []);
          }
        } catch (e) {
          console.warn('[Sliders] Transpile error:', e);
        }
      } else {
        console.warn('[Sliders] Strudel transpiler function not found');
      }
    };

    const debouncedUpdateSliders = debounce((code) => {
       window.updateSlidersFromCode(code);
    }, 300);

    window.syncSliderDefinitions = debounce(function(defs) {
      if (!_isMaster) return;
      if (_ws && _ws.readyState === WebSocket.OPEN) {
        _ws.send(JSON.stringify({
          type: 'register_sliders',
          sliders: defs
        }));
      }
    }, 500);

    // ‚îÄ‚îÄ‚îÄ CodeMirror Editor ‚îÄ‚îÄ‚îÄ
    let editor = null;
    function initEditor() {
      editor = CodeMirror(document.getElementById('code-editor-wrap'), {
        value: '// Ê≠£Âú®Âä†ËΩΩ Strudel‚Ä¶',
        mode: 'javascript',
        theme: 'material-darker',
        lineNumbers: true,
        matchBrackets: true,
        autoCloseBrackets: true,
        tabSize: 2,
        indentWithTabs: false,
        lineWrapping: true,
        extraKeys: {
          'Ctrl-Enter': () => runEditorCode(),
          'Cmd-Enter':  () => runEditorCode(),
        },
      });
      
      // Listen for code changes to update UI sliders bi-directionally
      editor.on('change', (instance, changeObj) => {
         // If change comes from slider drag, ignore to avoid loop
         if (changeObj.origin === 'slider') return;
         debouncedUpdateSliders(instance.getValue());
      });
    }
    initEditor();

    function showCode(text) {
      if (editor) {
        editor.setValue(text);
        setTimeout(() => editor.refresh(), 10);
      }
    }

    // Run whatever is in the editor
    async function runEditorCode() {
      if (!strudelReady) { showNotification('Strudel ËøòÂú®ÂàùÂßãÂåñ‚Ä¶'); return; }
      const code = editor.getValue();
      try {
        _clearInlineWidgets();      // remove old visualizations
        await safeEvaluate(code);
        _insertInlineWidgets(editor); // insert new inline canvases
        updatePlayState(true);
        showNotification('‚úÖ ‰ª£Á†ÅÂ∑≤ÊâßË°å');
        syncCodeToServer(code); // keep server in sync
      } catch (e) {
        console.error('[Strudel] Editor eval error:', e);
        showNotification('‚ùå ' + e.message);
        reportErrorToServer(e); // Report back to server -> mobile user
      }
    }

    document.getElementById('btn-run').addEventListener('click', () => runEditorCode());
    document.getElementById('btn-reset').addEventListener('click', () => {
      showCode(PATTERNS[currentPatternIndex].code);
      showNotification('Â∑≤ÈáçÁΩÆ‰∏∫È¢ÑËÆæ‰ª£Á†Å');
    });

    function safeHush() {
      try {
        if (typeof _hush === 'function') { _hush(); return; }
        if (typeof hush === 'function') { hush(); return; }
        if (typeof strudel !== 'undefined' && typeof strudel.hush === 'function') { strudel.hush(); return; }
        console.warn('[hush] no hush function available!');
      } catch(e) { console.error('[hush] error:', e); }
    }

    async function safeEvaluate(code) {
      const transpileFn = getTranspiler();
      let codeToRun = code;
      
      // 1. First, transpile just to extract widgets/sliders for our UI
      if (typeof transpileFn === 'function') {
        try {
          if (typeof window.ensureWidgetsRegistered === 'function') {
            window.ensureWidgetsRegistered();
          }
          const result = transpileFn(code, { emitWidgets: true });
          if (typeof window._renderSliders === 'function') {
            window._renderSliders(result.widgets || result.sliders || []);
          }
          // Use the transpiled code which has sliderWithID calls
          if (result.code) {
             codeToRun = result.code;
          }
        } catch (e) {
          console.warn('[safeEvaluate] Widget extraction failed:', e);
        }
      }
      
      // 2. Now use the actual Strudel evaluator to run the code.
      // This handles $: syntax, scheduling, and reactivity properly.
      const evalFn = _evaluate || evaluate || (strudel && strudel.evaluate);
      if (typeof evalFn === 'function') {
        return await evalFn(codeToRun);
      }
      
      throw new Error('evaluate() not available');
    }

    async function playCurrentPattern() {
      if (!strudelReady) { showNotification('Strudel ËøòÂú®ÂàùÂßãÂåñ‚Ä¶'); return; }
      // Use editor content (may have been edited by user)
      const code = editor ? editor.getValue() : PATTERNS[currentPatternIndex].code;
      try {
        _clearInlineWidgets();      // remove old visualizations
        await safeEvaluate(code);
        _insertInlineWidgets(editor); // insert new inline canvases
        updatePlayState(true);
        syncCodeToServer(code); // keep server in sync
      } catch (e) {
        console.error('[Strudel] Play error:', e);
        showNotification('Êí≠ÊîæÂá∫Èîô: ' + e.message);
      }
    }

    function stopPlayback() {
      safeHush();
      _clearInlineWidgets();        // remove inline visualizations
      const testCanvas = document.getElementById('test-canvas');
      if (testCanvas) { const ctx = testCanvas.getContext('2d'); ctx.clearRect(0, 0, testCanvas.width, testCanvas.height); }
      const scopeCanvas = document.getElementById('scope-canvas');
      if (scopeCanvas) { const ctx = scopeCanvas.getContext('2d'); ctx.clearRect(0, 0, scopeCanvas.width, scopeCanvas.height); }
      updatePlayState(false);
    }

    function switchPattern(index) {
      currentPatternIndex = index;
      document.querySelectorAll('.pattern-btn').forEach((btn, i) => btn.classList.toggle('active', i === index));
      showCode(PATTERNS[index].code);
      syncCodeToServer(PATTERNS[index].code); // keep server in sync
      if (isPlaying) playCurrentPattern();
      showNotification(PATTERNS[index].name);
    }

    const btnPlay = document.getElementById('btn-play');
    const btnStop = document.getElementById('btn-stop');

    function updatePlayState(playing) {
      isPlaying = playing;
      btnPlay.classList.toggle('active', playing);
      const playIcon = btnPlay.querySelector('.material-symbols-rounded');
      const playText = btnPlay.childNodes[btnPlay.childNodes.length - 1];
      playIcon.textContent = 'play_arrow';
      playText.textContent = playing ? '\u64ad\u653e\u4e2d' : '\u64ad\u653e';
      document.getElementById('status-text').textContent = playing ? '\ud83d\udd0a \u64ad\u653e\u4e2d' : '\u5c31\u7eea';
      document.getElementById('play-dot').classList.toggle('stopped', !playing);
      document.getElementById('code-label-text').textContent = playing ? '\u6b63\u5728\u64ad\u653e' : '\u5f53\u524d\u4ee3\u7801';
      
    // Sync state to server if Master
      if (_isMaster) {
        syncStateToServer(playing);
      }
    }

    btnPlay.addEventListener('click', () => playCurrentPattern());
    btnStop.addEventListener('click', () => stopPlayback());

    document.getElementById('start-btn').addEventListener('click', async () => {
      const overlay = document.getElementById('start-overlay');
      const app = document.getElementById('app');
      overlay.classList.add('hidden');
      app.style.display = 'flex';
      setupScopeCanvas();
      if (editor) setTimeout(() => editor.refresh(), 100);
      document.getElementById('status-text').innerHTML = '<span class="spinner"></span>\u00a0\u6b63\u5728\u521d\u59cb\u5316\u2026';
      try {
        // ‚îÄ‚îÄ initStrudel prebake matching strudel.cc ‚îÄ‚îÄ
        const CDN = 'https://strudel.b-cdn.net';
        
        // Helper for robust sample loading with timeout
        async function loadSamples(name, ...args) {
          const timeout = 15000; // 15 seconds timeout
          const maxRetries = 1;
          
          for (let i = 0; i <= maxRetries; i++) {
            try {
              const promise = samples(...args);
              const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Timeout')), timeout)
              );
              return await Promise.race([promise, timeoutPromise]);
            } catch (err) {
              console.warn(`[Samples] Failed to load ${name} (attempt ${i+1}):`, err);
              if (i === maxRetries) return null;
              await new Promise(r => setTimeout(r, 1000));
            }
          }
        }

        await initStrudel({
          prebake: () => Promise.allSettled([
            // Register ZZFX sounds
            typeof registerZZFXSounds === 'function' ? registerZZFXSounds() : Promise.resolve(),
            // Dirt-Samples - Extended (loading full strudel.json from repo to support non-standard samples like voodoo, wind, etc.)
            loadSamples('dirt-extended', 'https://raw.githubusercontent.com/tidalcycles/Dirt-Samples/master/strudel.json'),
            // Standard Dirt-Samples (shorthand)
            loadSamples('dirt', 'github:tidalcycles/dirt-samples'),
            // Piano samples
            loadSamples('piano', `${CDN}/piano.json`, `${CDN}/piano/`, { prebake: false }),
            // Superpiano samples - with robust fallback to piano
            loadSamples('superpiano', `${CDN}/superpiano.json`, `${CDN}/superpiano/`, { prebake: false })
              .then(res => {
                if (!res) {
                  console.warn('[Samples] Superpiano failed (not in standard set), falling back to piano samples');
                  // Fallback: load piano.json, rename key to superpiano, and register
                  return fetch(`${CDN}/piano.json`)
                    .then(r => r.json())
                    .then(data => {
                      if (data.piano) {
                        data.superpiano = data.piano;
                        console.log('[Samples] Registered superpiano using piano samples fallback');
                        return samples(data, `${CDN}/piano/`);
                      }
                    })
                    .catch(e => console.warn('Fallback failed:', e));
                }
                return res;
              }),
            // VCSL
            loadSamples('vcsl', `${CDN}/vcsl.json`, `${CDN}/VCSL/`, { prebake: false }),
            // Tidal drum machines
            loadSamples('tidal-drums', `${CDN}/tidal-drum-machines.json`, `${CDN}/tidal-drum-machines/machines/`, {
              prebake: false, tag: 'drum-machines',
            }),
            // Uzu drumkit
            loadSamples('uzu-drums', `${CDN}/uzu-drumkit.json`, `${CDN}/uzu-drumkit/`, {
              prebake: false, tag: 'drum-machines',
            }),
            // Uzu wavetables
            loadSamples('uzu-waves', `${CDN}/uzu-wavetables.json`, `${CDN}/uzu-wavetables/`, { prebake: false }),
            // Mridangam
            loadSamples('mridangam', `${CDN}/mridangam.json`, `${CDN}/mrid/`, { prebake: false, tag: 'drum-machines' }),
          ]).then(() => {
            if (typeof aliasBank === 'function') {
              aliasBank(`${CDN}/tidal-drum-machines-alias.json`).catch(e => console.warn('aliasBank failed', e));
            }
            
            // ‚îÄ‚îÄ Register Aliases for Missing Synths ‚îÄ‚îÄ
            // Ensures supersquare, supersaw, arpy, etc. have fallbacks
            try {
              const registerAlias = (alias, target) => {
                // Try global scope first
                let reg = typeof registerSound === 'function' ? registerSound : null;
                let map = typeof soundMap !== 'undefined' ? soundMap : null;
                
                // Try strudel global
                if (!reg && typeof strudel !== 'undefined') {
                  reg = strudel.registerSound || (strudel.superdough && strudel.superdough.registerSound);
                  map = strudel.soundMap || (strudel.superdough && strudel.superdough.soundMap);
                }
                
                if (reg && map) {
                  // Check if alias already exists to avoid overwriting real implementations (e.g. supersaw)
                  if (map.get(alias)) {
                     console.log(`[Alias] ${alias} is already registered. Skipping alias to ${target}.`);
                     return;
                  }

                  const targetSound = map.get(target);
                  if (targetSound) {
                    reg(alias, targetSound.onTrigger, targetSound.data);
                    console.log(`[Alias] Registered ${alias} -> ${target}`);
                  } else {
                    console.warn(`[Alias] Target ${target} not found for ${alias}`);
                  }
                }
              };

              registerAlias('supersquare', 'square');
              registerAlias('supersaw', 'sawtooth');
              registerAlias('arpy', 'triangle'); // Arpy fallback
            } catch (e) {
              console.warn('[Alias] Failed to register aliases:', e);
            }
          }),
        });
        strudelReady = true;
        _hush = window.hush || null;
        _evaluate = window.evaluate || null;
        
        // Ensure widgets are registered now that Strudel is fully ready
        window.ensureWidgetsRegistered();
        
        console.log('[Strudel] Ready! _hush:', typeof _hush, '_evaluate:', typeof _evaluate);
        document.getElementById('status-text').textContent = '\u2705 \u5c31\u7eea';
        showCode(PATTERNS[0].code);
        generateQR();
      } catch (e) {
        console.error('[Strudel] Init error:', e);
        document.getElementById('status-text').textContent = '\u274c \u521d\u59cb\u5316\u5931\u8d25';
      }
    });

    function generateQR() {
      // Dynamic URL generation
      let url;
      if (window.location.port === '5173') {
         // Vite dev mode: point to the Express server for the mobile client
         url = `${window.location.protocol}//${window.location.hostname}:3000/submit`;
      } else {
         // Production/Express mode: relative to current origin
         url = `${window.location.origin}/submit`;
      }
      
      const qrImg = document.getElementById('qr-img');
      qrImg.src = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(url)}&bgcolor=141218&color=E6E0E9&format=svg`;
      qrImg.style.display = 'block';
    }

    function showNotification(text) {
      const el = document.createElement('div');
      el.className = 'notification';
      el.textContent = text;
      document.body.appendChild(el);
      requestAnimationFrame(() => el.classList.add('show'));
      setTimeout(() => { el.classList.remove('show'); setTimeout(() => el.remove(), 300); }, 3000);
    }

    window.updateStrudelCode = async function(code, name, shouldPlay = true) {
      if (!strudelReady) return;
      try {
        // 1. Always update editor content first
        showCode(code);
        
        // 2. Only evaluate (play) if shouldPlay is true
        if (shouldPlay) {
          _clearInlineWidgets();
          await safeEvaluate(code);
          updatePlayState(true);
          _insertInlineWidgets(editor);
        } else {
          // If we shouldn't play, ensure we are stopped
          if (isPlaying) {
            stopPlayback();
          }
        }
        
        if (name) showNotification(name);
      } catch(e) {
        console.error('[Strudel] Code eval error:', e);
        showNotification('‚ùå ‰ª£Á†ÅÊâßË°åÂá∫Èîô');
        reportErrorToServer(e); // Report back to server -> mobile user
      }
    };

    // Refresh editor when app becomes visible (after overlay dismiss)
    const appObserver = new MutationObserver(() => {
      if (document.getElementById('app').style.display !== 'none' && editor) {
        setTimeout(() => editor.refresh(), 50);
      }
    });
    appObserver.observe(document.getElementById('app'), { attributes: true, attributeFilter: ['style'] });

    // ‚îÄ‚îÄ WebSocket Integration ‚îÄ‚îÄ
    let _ws = null; // global reference for code sync
    let _lastSessionId = null; // track which user triggered the current code
    let _isMaster = false; // am I the master screen?
    let _serverIsPlaying = false; // Track server state

    function syncCodeToServer(code) {
      if (_isMaster && _ws && _ws.readyState === WebSocket.OPEN) {
        _ws.send(JSON.stringify({ type: 'sync_code', code }));
      }
    }

    function syncSliderToServer(id, value) {
        if (_isMaster && _ws && _ws.readyState === WebSocket.OPEN) {
            _ws.send(JSON.stringify({ type: 'sync_slider', id, value }));
        }
    }

    function syncStateToServer(playing) {
      if (_isMaster && _ws && _ws.readyState === WebSocket.OPEN) {
        _ws.send(JSON.stringify({ type: 'sync_state', playing }));
      }
    }
    
    function reportErrorToServer(error) {
      if (_ws && _ws.readyState === WebSocket.OPEN && _lastSessionId) {
        _ws.send(JSON.stringify({ 
          type: 'execution_error', 
          message: error.message || String(error),
          sessionId: _lastSessionId
        }));
      }
    }

    function connectWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      // Use standard ports (80/443) when using domain names, fall back to current port if not 80/443
      const port = (window.location.port === '80' || window.location.port === '443' || window.location.port === '') ? '' : ':3000';
      
      // Get auth key from URL
      const urlParams = new URLSearchParams(window.location.search);
      const authKey = urlParams.get('key');
      
      const wsUrl = `${protocol}//${window.location.hostname}${port}/ws?type=screen&key=${authKey || ''}`;
      console.log('Connecting to WS:', wsUrl);
      const ws = new WebSocket(wsUrl);
      _ws = ws;

      ws.onopen = () => {
        console.log('WS Connected');
        showNotification('Â∑≤ËøûÊé•ÊúçÂä°Âô®');
      };

      ws.onmessage = (e) => {
        try {
          const msg = JSON.parse(e.data);
          handleWsMessage(msg);
        } catch (err) {
          console.error(err);
        }
      };

      ws.onclose = () => {
        console.log('WS Closed');
        showNotification('ÊúçÂä°Âô®Êñ≠ÂºÄËøûÊé•');
        setTimeout(connectWebSocket, 3000);
      };
    }

    function handleWsMessage(msg) {
      if (msg.type === 'init') {
        _isMaster = (msg.role === 'master');
        _serverIsPlaying = !!msg.isPlaying;

        if (_isMaster) {
           showNotification('üëë ‰∏ªÊéßÊ®°ÂºèÂ∑≤ÊøÄÊ¥ª');
           document.body.classList.add('mode-master');
           document.body.classList.remove('mode-viewer');
        } else {
           showNotification('üëÄ ËßÇ‰ºóÊ®°Âºè (Âè™ËØª)');
           document.body.classList.add('mode-viewer');
           document.body.classList.remove('mode-master');
           // Set editor to read-only
           if (editor) editor.setOption('readOnly', true);
           // Update Start Button for Viewers
           const btn = document.getElementById('start-btn');
           if (btn) {
             btn.innerHTML = '<span class="material-symbols-rounded">visibility</span> ËøõÂÖ•ËßÇÁúã';
             // Add a small note about audio sync
             const sub = document.querySelector('#start-overlay .subtitle');
             if(sub) sub.textContent = 'ÂêåÊ≠•ÁîªÈù¢‰∏éÈü≥È¢ëÈúÄË¶ÅÁÇπÂáªËøõÂÖ•';
           }
        }
        
        if (msg.code) {
           // Update code, play only if server is playing
           window.updateStrudelCode(msg.code, 'ÂàùÂßãÂåñÂêåÊ≠•', _serverIsPlaying);
        }
        if (msg.recentPrompts) updateTicker(msg.recentPrompts);
      }

      if (msg.type === 'play_state') {
        _serverIsPlaying = !!msg.playing;
        if (!_isMaster && strudelReady) {
          if (_serverIsPlaying) {
             if (!isPlaying) playCurrentPattern();
          } else {
             if (isPlaying) stopPlayback();
          }
        }
      }

      if (msg.type === 'request_code') {
        // Only Master responds to code requests
        if (_isMaster && _ws && _ws.readyState === WebSocket.OPEN && editor) {
          _ws.send(JSON.stringify({ 
            type: 'sync_code', 
            code: editor.getValue(),
            playing: isPlaying,
            requestId: msg.requestId // Echo back the request ID
          }));
        }
        return;
      }
      // Audience Control Force Application (Master Only)
      if (msg.type === 'apply_force') {
        const { id, force } = msg;
        if (_isMaster && id && window._sliderValues[id] !== undefined) {
          const input = document.querySelector('.slider-input[data-id="' + id + '"]');
          if (input) {
             const min = parseFloat(input.min);
             const max = parseFloat(input.max);
             const range = max - min;
             
             // Apply factor: e.g., max 2% of range per tick
             const speedFactor = 0.02; 
             const delta = force * range * speedFactor;
             
             let newVal = window._sliderValues[id] + delta;
             newVal = Math.max(min, Math.min(max, newVal));
             
             if (Math.abs(newVal - window._sliderValues[id]) > 1e-5) {
                window._sliderValues[id] = newVal;
                input.value = newVal;
                if (input.nextElementSibling) {
                    input.nextElementSibling.textContent = newVal.toFixed(2);
                }
                
                if (editor && window._sliderMarkers[id]) {
                   updateSliderCode(id, newVal);
                }
                window.postMessage({ type: 'cm-slider', id: id, value: newVal }, '*');
                
                // Broadcast update to Viewers
                if (typeof syncSliderToServer === 'function') {
                   syncSliderToServer(id, newVal);
                }
             }
          }
        }
      }

      if (msg.type === 'slider_update') {
          // Received slider update from Master (Viewer only)
          if (!_isMaster) {
              const { id, value } = msg;
              if (id && value !== undefined) {
                  // Post message to trigger both our listener (UI/Code/State) AND Strudel's internal listener
                  window.postMessage({ type: 'cm-slider', id, value: parseFloat(value) }, '*');
              }
          }
      }
      
      if (msg.type === 'code_update') {
        const code = msg.code;
        const prompt = msg.prompt;
        // Update session tracking
        _lastSessionId = msg.sessionId;
        
        // Construct notification message (only if prompt is provided)
        const notification = prompt ? `ü§ñ AI: ${prompt}` : null;
        
        // Update code, play only if server is playing
        window.updateStrudelCode(code, notification, _serverIsPlaying);
        if (msg.recentPrompts) updateTicker(msg.recentPrompts);
      }
    }

    function updateTicker(prompts) {
       const inner = document.getElementById('ticker-inner');
       if(!inner) return;
       inner.innerHTML = prompts.map(p => `<span class="ticker-item">üí¨ ${p}</span>`).join('') + 
         `<span class="ticker-item">ü•ß Êèê‰∫§‰Ω†ÁöÑÂàõÊÑè!</span>`;
    }

    // Connect WS immediately on page load (before user clicks Start)
    // This ensures code sync works even before audio is playing
    connectWebSocket();

    // Also reconnect if needed when user starts audio
    document.getElementById('start-btn').addEventListener('click', () => {
      if (!_ws || _ws.readyState !== WebSocket.OPEN) connectWebSocket();
      
      // If server is already playing, start playback immediately after init
      // We check this in a short interval because strudelReady might take a moment after click
      // But strudelReady is set inside the click handler (see start-btn listener above)
      // Actually, the click handler above (lines 1000+) sets strudelReady = true.
      // So we can check immediately if we are after that handler.
      // However, this listener is added AFTER the first one?
      // Yes, this script block is at the end of body.
      // The first listener is inside DOMContentLoaded? No, it's inside init() which is called on load?
      // Wait, where is the main start-btn listener?
      // It's in the script block starting at line 984:
      // document.getElementById('start-btn').addEventListener('click', async () => { ... strudelReady = true ... });
      
      // So this listener (line 1206) runs AFTER the main one?
      // Yes, if added later.
      // So strudelReady should be true (or Promise pending).
      // Wait, the main listener is `async`. It awaits `initAudioContext` and `loadSamples`.
      // So `strudelReady` won't be true immediately.
      
      // We need to hook into the completion of the main listener.
      // Or just poll.
      const checkReady = setInterval(() => {
        if (strudelReady) {
          clearInterval(checkReady);
          if (!_isMaster && _serverIsPlaying && !isPlaying) {
             playCurrentPattern();
          }
        }
      }, 100);
    });
  </script>
</body>
</html>
